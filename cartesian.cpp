/*
 * cartesian.cpp
 *
 * Created: 26.1.2015 11:39:48
 *  Author: Kremmen
 */
#include "cartesian.h"
#include "Arduino.h"
#include "SMDOvenGPIO.h"

gText::gText(int16_t X1, int16_t Y1, int16_t X2, int16_t Y2, gEvHandler handler):ILI9341_due_gText(X1,Y1,X2,Y2){
	gTextEventHandler = handler;
}

void gText::show() {
	;
}

void gText::handleEvent( View *vi, event_t ev ) {
	if ( gTextEventHandler ) gTextEventHandler( vi, this, ev ); 
}


PGM_TextArea::PGM_TextArea(int16_t X1, int16_t Y1, int16_t X2, int16_t Y2, uint16_t but_color, uint16_t txt_color, PGM_P txt[], gEvHandler handler):gText(X1,Y1,X2,Y2,handler) {
	text = txt;
	_fontBgColor = but_color;
	_fontColor = txt_color;
	_fontMode = gTextFontMode_Solid;
}


void PGM_TextArea::show() {
uint16_t cnt,t_X,t_Y,fH;
	clearArea(_fontBgColor);
	selectFont( calibri );
	fH = fontHeight();
	setFontColor( _fontColor, _fontBgColor);
	cnt = 0;
	t_X = fH/2; t_Y = fH/2;
	while (text[cnt]) {
		drawString_P( text[cnt], t_X, t_Y);
		t_Y += fH;
		cnt++;	
	}
}

TextArea::TextArea(int16_t X1, int16_t Y1, int16_t X2, int16_t Y2, uint16_t but_color, uint16_t txt_color, char *txt[], gEvHandler handler):gText(X1,Y1,X2,Y2,handler) {
	text = txt;
	_fontBgColor = but_color;
	_fontColor = txt_color;
	_fontMode = gTextFontMode_Solid;
}


void TextArea::show() {
uint16_t cnt,t_X,t_Y,fH;
	clearArea(_fontBgColor);
	selectFont( calibri );
	fH = fontHeight();
	setFontColor( _fontColor, _fontBgColor);
	cnt = 0;
	t_X = fH/2; t_Y = fH/2;
	while (text[cnt]) {
		drawString( text[cnt], t_X, t_Y);
		t_Y += fH;
		cnt++;
	}
}
Caption::Caption( int16_t X1, int16_t Y1, int16_t X2, int16_t Y2, uint16_t but_color, uint16_t txt_color, const char *txt, gEvHandler handler ):gText(X1,Y1,X2,Y2,handler) {
char *textp;
uint8_t cnt;
	_fontBgColor = but_color;
	_fontColor = txt_color;
	_fontMode = gTextFontMode_Solid;
	textAlignment = gTextAlignMiddleCenter;
	textp = &text[0];
	for ( cnt = 0; cnt < CAPTIONLENGTH; cnt++ ) {
		if ( !( *textp++ = *txt++ ) ) break;
	}
	selectFont( calibri );
	setFontColor( _fontColor, _fontBgColor);
}

void Caption::show() {
	clearArea(_fontBgColor);
	_ili->drawRect(_area.x1, _area.y1, _area.x2-_area.x1+1, _area.y2-_area.y1+1, ILI9341_BLACK);
	drawString( text, textAlignment);
}

void Caption::appendText( char *txt ) {
	strncat(text, txt, CAPTIONLENGTH);
}

void Caption::appendChar( char ch ) {
	char *textp;
	uint8_t cnt =0;
	textp = &text[0];
	while ( *textp ) {
		cnt++;
		textp++;
	}
	if ( cnt < CAPTIONLENGTH-1 ) {
		*textp++ = ch;
		*textp = 0x00;
	}
}

void Caption::setFloat( char *fmt, double num ) {
	sprintf( text, fmt, num );
	textAlignment = gTextAlignMiddleRight;
}

void Caption::setInteger( int32_t num ) {
	sprintf( text, "%i", num );
	textAlignment = gTextAlignMiddleRight;
}

char *Caption::findChar( char ch ) {
	return strchr( text, ch );
}

void Caption::backSpace() {
	char *textp;
	uint8_t cnt =0;
	textp = &text[0];
	while ( *textp ) {
		cnt++;
		textp++;
	}
	if ( cnt > 0 ) {
		textp--;
		*textp = 0x00;
	}
}

void Caption::clear() {
	for ( uint8_t cnt = 0; cnt < CAPTIONLENGTH; cnt++ ) text[cnt] = 0x00;	
}

/*! \brief Button-luokan peruskonstruktori

	Konstruktori ottaa argumentteina widgetin koordinaatit, esitettävän tekstin värit ja stringin sekä osoittimen tapahtumankäsittelijään
	\param X1, Y1, X2, Y2 koordinaatit
	\param but_color napin pohjaväri
	\param txt_color tekstin väri
	\param cap otsikkoteksti
	\param gEvHandler osoitin tapahtumankäsittelijään
*/
Button::Button( int16_t X1, int16_t Y1, int16_t X2, int16_t Y2, uint16_t but_color, uint16_t txt_color, const char *cap, gEvHandler handler):gText(X1,Y1,X2,Y2,handler) {
	strcpy(caption,cap);
	selectFont( calibri );
	_fontBgColor = but_color;
	_fontColor = txt_color;
	_fontMode = gTextFontMode_Solid;
	setFontColor( _fontColor, _fontBgColor);
}

/*! \brief Button-luokan päivitys näkymään

	Metodi siivoaa Buttonin koordinaatiien alan taustaväriseksi, piirtää yksinkertaisen "varjostetun" laatikon
	sekä tulostaa Buttonin tekstin laatikkoon alustetulla värillä
*/
void Button::show() {
	clearArea(_fontBgColor);
	_ili->drawFastHLine(_area.x1, _area.y1, _area.x2-_area.x1, ILI9341_WHITE);
	_ili->drawFastHLine(_area.x1, _area.y2, _area.x2-_area.x1, ILI9341_BLACK);
	_ili->drawFastVLine(_area.x1, _area.y1, _area.y2-_area.y1, ILI9341_WHITE);
	_ili->drawFastVLine(_area.x2, _area.y1, _area.y2-_area.y1, ILI9341_BLACK);
	drawString( caption, gTextAlignMiddleCenter);
}

Plot::Plot(uint16_t numDataPoints) {
	point = (step_t *)malloc( numDataPoints * sizeof( step_t) );
	if ( point ) { 
		maxPoints = numDataPoints;
	}
	else maxPoints = 0;
	insertIndex = 0;
}

Plot::~Plot() {
	free( point );
}

boolean Plot::addPoint( step_t pt ) {
	if ( insertIndex < maxPoints-1 ) {
		point[insertIndex++] = pt;
		return true;
	}
	else return false;
}

boolean Plot::getPoint( step_t *pt, uint16_t index ) {
	if ( index < insertIndex ) {
		*pt = point[index];
		return true;
	}
	else return false;
}

void Plot::show(cartesian *c ) {
uint16_t cnt;
	if ( insertIndex > 0 ) {
		for (cnt = 0; cnt < insertIndex-1; cnt ++ ) {
			c->drawLine( point[cnt].timeOffset,point[cnt].tempC,point[cnt+1].timeOffset,point[cnt+1].tempC );
		}
	}
}


/*! \brief Axis-kantaluokan peruskonstruktori

	Konstruktori ottaa argumentteina esitettävän tekstin värit ja stringin sekä osoittimen tapahtumankäsittelijään.
	Huom: kantaluokan konstruktoria saa kutsua vain johdetun luokan konstruktorista koska suoraan kutsuminen ei ole mielekästä.
	\param but_color "napin" pohjaväri joka määrää koordinaatiston taustavärin
	\param txt_color tekstin väri
	\param Min, Max koordinaatin raja-arvot skaalattuina mittasignaalin arvoalueeseen
	\param sTick Akselin rasterimerkintöjen väli skaalattuna mittasignaaliin
*/
Axis::Axis( uint16_t but_color, uint16_t txt_color, float sMin, float sMax, float sTick ):ILI9341_due_gText(0,0,1,1) {
	_font = calibri;
	_fontBgColor = but_color;
	_fontColor = txt_color;
	scaleMin = sMin;
	scaleMax = sMax;
	scaleTick = sTick;
	ticksOn = true;
	gridOn = true;
}

/*! \brief Axis-kantaluokan tekstilabelin leveys pikseleinä

	Funktio palauttaa akselin suurinta skaalalukemaa vastaavan stringin leveyden pikseleinä.
	Käytetään kohdistettaessa akseleita koordinaatiston näyttöalaan. 
*/
int16_t Axis::getTextWidth() {
char s[10];
char *sptr;
	sptr = &s[0];
	itoa( ( int16_t )scaleMax, sptr, 10);
	return stringWidth( sptr );
}

/*! \brief Axis-kantaluokan päivitys näyttöön

	Metodi siivoaa akselin piirtoalan täyttämällä sen taustavärillä.
	Metodia kutsutaan johdetun akseliluokan näytönpäivityksestä. 
*/
void Axis::show() {
	_ili->fillRect(_area.x1,_area.y1,_area.x2-_area.x1,_area.y2-_area.y1,_fontBgColor);
}

/*! \brief Vasemman laidan akseliluokan konstruktori

	Konstruktori ottaa argumentteina esitettävän tekstin värit ja stringin sekä osoittimen tapahtumankäsittelijään.
	Konstruktorina käytetään kantaluokan konstruktoria suoraan.
	\param but_color "napin" pohjaväri joka määrää koordinaatiston taustavärin
	\param txt_color tekstin väri
	\param Min, Max koordinaatin raja-arvot skaalattuina mittasignaalin arvoalueeseen
	\param sTick Akselin rasterimerkintöjen väli skaalattuna mittasignaaliin
*/
LeftAxis::LeftAxis( uint16_t but_color, uint16_t txt_color, float sMin, float sMax, float sTick ):Axis(but_color,txt_color,sMin,sMax,sTick) {
}

/*! \brief Vasemman laidan akselin päivitys näyttöön

	Päivitys piirtää akselin koordinatiston vasempaan laitaan.
	\todo	asemoi akseliviiva niin että skaalanumeron leveys huomioidaan
*/
void LeftAxis::show() {
float tickValue, tickValToPX;
int32_t tickIndex;
uint16_t t_X, t_Y;
	Axis::show();
	_ili->drawFastVLine( _area.x2, _y ,_area.y2-_area.y1, _fontColor );
	tickValToPX = ( _area.y2-_area.y1 ) / ( scaleMax - scaleMin );	// muunnoskerroin pikseliä / yksikkö jos pystyakseli
	tickIndex = ( uint32_t ) ( ( scaleMin / scaleTick ) + 1 );
	tickValue = tickIndex * scaleTick;
	while ( tickValue <= scaleMax ) {
		t_X = _area.x2 - MAJORTICKWIDTH;
		t_Y = _area.y2 - ( uint16_t ) ( tickValToPX * ( tickValue - scaleMin ) );
		_ili->drawFastHLine( t_X, t_Y, MAJORTICKWIDTH, _fontColor );
		t_X = _x;
		t_Y -= 3;
		_ili->setCursor( t_X, t_Y );
		_ili->setTextColor( _fontColor );
		_ili->println( ( int16_t ) tickValue );
		tickIndex += 1;
		tickValue = tickIndex * scaleTick;
	}
}

/*! \brief Alalaidan akseliluokan konstruktori

	Konstruktori ottaa argumentteina esitettävän tekstin värit ja stringin sekä osoittimen tapahtumankäsittelijään.
	Konstruktorina käytetään kantaluokan konstruktoria suoraan.
	\param but_color "napin" pohjaväri joka määrää koordinaatiston taustavärin
	\param txt_color tekstin väri
	\param Min, Max koordinaatin raja-arvot skaalattuina mittasignaalin arvoalueeseen
	\param sTick Akselin rasterimerkintöjen väli skaalattuna mittasignaaliin
*/
BottomAxis::BottomAxis( uint16_t but_color, uint16_t txt_color, float sMin, float sMax, float sTick ):Axis(but_color,txt_color,sMin,sMax,sTick) {
}

/*! \brief Alalaidan akselin päivitys näyttöön

	Päivitys piirtää akselin koordinatiston alalaitaan.
	\todo	asemoi akseliviiva niin että skaalanumeron korkeus huomioidaan
*/
void BottomAxis::show() {
float tickValue, tickValToPX;
int32_t tickIndex;
uint16_t t_X, t_Y;
	Axis::show();
	_ili->drawFastHLine( _x, _y,_area.x2 - _area.x1, _fontColor );
	tickValToPX = ( _area.x2 - _area.x1 ) / (scaleMax - scaleMin);	// muunnoskerroin pikseliä / yksikkö jos vaaka-akseli
	tickIndex = ( uint32_t) ( ( scaleMin / scaleTick ) + 1 );
	tickValue = tickIndex * scaleTick;
	while ( tickValue <= scaleMax ) {
		t_Y = _y;
		t_X = _x  + ( uint16_t ) ( tickValToPX * ( tickValue - scaleMin ) );
		_ili->drawFastVLine( t_X, t_Y, MAJORTICKWIDTH, _fontColor );
		t_Y = _y + 6;
		t_X -= 10;
		_ili->setCursor( t_X, t_Y );
		_ili->setTextColor( _fontColor );
		_ili->println( (int16_t) tickValue );
		tickIndex += 1;
		tickValue = tickIndex * scaleTick;
	}
}

RightAxis::RightAxis( uint16_t but_color, uint16_t txt_color, float sMin, float sMax, float sTick ):Axis(but_color,txt_color,sMin,sMax,sTick) {
}

void RightAxis::show() {
float tickValue, tickValToPX;
int32_t tickIndex;
uint16_t t_X, t_Y;
	Axis::show();
	_ili->drawFastVLine( _x, _y,( _area.y2 - _area.y1 ), _fontColor );
	tickValToPX = ( _area.y2 - _area.y1 ) / (scaleMax - scaleMin);	// muunnoskerroin pikseliä / yksikkö jos pystyakseli
	tickIndex = ( uint32_t) ( ( scaleMin / scaleTick ) + 1 );
	tickValue = tickIndex * scaleTick;
	while ( tickValue <= scaleMax ) {
		t_X = _x;
		t_Y = _area.y2 - ( uint16_t ) ( tickValToPX * ( tickValue - scaleMin ) );
		_ili->drawFastHLine( t_X, t_Y, MAJORTICKWIDTH, _fontColor );
		t_X += 5;
		t_Y -= 3;
		_ili->setCursor( t_X, t_Y );
		_ili->setTextColor( _fontColor );
		_ili->println( (int16_t) tickValue );
		tickIndex += 1;
		tickValue = tickIndex * scaleTick;
	}
}

/*! \brief Koordinaatiston konstruktori

	Koordinatistolle määritellään konstruktorissa piirtoala ja tapahtumankäsittelijä joka kaappaa koordinaatiston alueelle osuvat kosketukset.
	\param X1,Y1,X2;Y2 koordinaatit
	\param color koordinaatiston pohjaväri
	\param gEvHandler widgetin tapahtumankäsittelijän osoite
*/
cartesian::cartesian( uint16_t X1, uint16_t Y1, uint16_t X2, uint16_t Y2, uint16_t color, gEvHandler handler ):gText(X1,Y1,X2,Y2,handler)  {
	p_X1 = X1; p_Y1 = Y1 + PLOTAREA_TOPMARGIN; p_X2 = X2 - PLOTAREA_RIGHTMARGIN; p_Y2 = Y2;
	_fontBgColor = color;
	leftAxis = NULL;
	bottomAxis = NULL;
	rightAxis = NULL;
}

/*! \brief Akselin assosiointi koordinaatistoon

	Metodi lisää koordinaatistoon akselin parametrilla indikoituun positioon. Positiossa mahdollisesti aiemmin ollut akseli korvataan uudella.
	Mikäli on tarvetta, setAxis sovittaa akseleiden risteyskohdat koordinaatiston nurkissa siten, että ne eivät mene päällekkäin.
	\param pos indikaattori haluttuun akselipositioon (enum axisPosition)
	\param *ax osoitin assosioitavaan akseliluokkaan
*/
void cartesian::setAxis(  axisPosition pos, Axis *ax  ) {
//Serial.println(">cartesian.setAxis");
	switch ( pos ) {
		case AXPOS_LEFT: {
			if ( leftAxis ) delete leftAxis;
			leftAxis = (LeftAxis *)ax;
			p_X1 = _area.x1 + ax->getTextWidth();
			break;
		}
		case AXPOS_BOTTOM: {
			if ( bottomAxis ) delete bottomAxis;
			bottomAxis = (BottomAxis *)ax;
			p_Y2 = _area.y2 - ax->getTextHeight();
			break;
		}
		case AXPOS_RIGHT: {
			if ( rightAxis ) delete rightAxis;
			rightAxis = (RightAxis *)ax;
			p_X2 = _area.x2 - ax->getTextWidth();
			break;
		}
		default: {
			
		}
	}
	if (leftAxis ) leftAxis->defineArea( 0, p_Y1, p_X1, p_Y2 );
	if (bottomAxis ) bottomAxis->defineArea( p_X1, p_Y2, p_X2, _area.y2 );
	if (rightAxis ) rightAxis->defineArea( p_X2, p_Y1, _area.x2, p_Y2 );
}

void cartesian::addPlot( Plot *pl ) {
	plotList.insertLast( pl );
}

/*! \brief Koordinaatiston päivitys näyttöön

	Metodi siivoaa koordinaatiston piirtoalan täyttämällä sen taustavärillä.
	Sen jälkeen päivitetään vuorollaan kaikki assosioidut akselit ja lopuksi iteroidaan kuvaajien lista läpi ja päivitetään jokainen kuvaaja.
	\todo aktivoi kuvaajan show() -metodi jahka se on toteutettu
*/
void cartesian::show() {
Plot *plot;
	_ili->fillRect(_area.x1,_area.y1,_area.x2-_area.x1,_area.y2-_area.y1,_fontBgColor);
	if ( leftAxis ) leftAxis->show();
	if ( bottomAxis ) bottomAxis->show();
	if ( rightAxis ) rightAxis->show();
	plot = (Plot *)plotList.getFirst();
	while ( plot ) {
		plot->show( this );
		plot = (Plot *)plotList.getNext();
	}
}


 int16_t cartesian::getPXPos(uint8_t index, float val) {
 	if ( (index & 0x01) == 0x00 ){
		return p_Y2 - ( val - leftAxis->getMin() ) * ( ( p_Y2 - p_Y1 ) / ( leftAxis->getMax() - leftAxis->getMin() ) );
	} else {
		return p_X1 + val * ( ( p_X2 - p_X1 ) / ( bottomAxis->getMax() - bottomAxis->getMin() ) );
	}
}

/*! \brief Skaalatun viivan piirto koordinatistoon

	Metodi piirtää viivan suoraan piirtoalalle lisäämättä sitä mihinkään kuvaajaan.
	Viivan x- ja y-koordinaatit ovat reaalimaailman skaalassa, ei pikseleitä.
	\param x0,y0,x1,y1 viivan päätepisteiden koordinaatit
	\todo lisää argumentit joilla viiva assosioidaaan X- ja Y-akseleihin
	\todo toteuta metodi! (mutta vain jos oikeasti tarvitaan)
*/
void cartesian::drawLine(float x0, float y0, float x1, float y1) {
	_ili->drawLine(getPXPos(1, x0), getPXPos(0, y0), getPXPos(1, x1), getPXPos(0, y1), 0x0000 );
}

//-------------------------------------------------------

boolean View::screenIsDirty;

/*! \brief View-luokan oletuskonstruktori. Ei juuri hyödyllinen koska muut tarvittavat metodit puuttuu
*/
View::View() {
	preInit = NULL;
	postInit = NULL;
	finalize = NULL;
	viewHandler = NULL;
}

/*! \brief View-luokan factory-konstruktori.

	Kaikki näytöllä näkyvät jutut kuuluvat johonmkin kerralla esitettävään näkymään joka on toteutettu tämän View-luokan instanssina.
	Näkymässä olevat widgetit synnytetään kahdella tavalla:
	1:	Suoraan konstruktorissa joka toimii widgetfactoryna. Widgetit on listattu staattiseen struktuuriin joka annetaan argumenttina konstruktorille
		Konstruktori käy listan läpi ja luo halutun tyyppisen widgetin annettujen parametrien mukaisesti.
	2:	Alustuken yhteydessä tai myöhemminkin kutsumalla Viewin add-metodia jolla näkymään lisätään itse "käsin" luotuja widgettejä. Tässä tapauksessa pitää
		kiinnittää huomiota luontijärjestykseen koska se määrää widgettien indeksin listalla. Lista on tärkeä työkalu widgettejä ja niiden sisältöä manipuloitaessa.
		View::add() lisää widgetin aina listan viimeiseksi jolloin se saa suurimman senhetkisen indeksin. Indeksit alkaa nollasta.
	\param elems luontistruktuurin elemnttien (widgettien) lukumäärä
	\param elemparams[] widgettien luontistruktuuri
	\param preinit osoitin esialustusproseduuriin joka ajetaan ennen widgettien konstruoimista. Tästä ei saa viitata widget-listaan koska ei ole widgettejä vielä!
	\param postinit osoitin jälkialustusproseduuriin joka ajetaan kun kaikki listalla olevat widgetit on luotu ja olemassa.
	\param preshow osoitin päivityksen valmisteluproseduuriin joka ajetaan aina ennen View::show() -metodia.
	\param final osoitin näkymän lopetusproseduuriin joka ajetaan juuri ennen näkymän destruktoria. Jos näkymään on käsin allokoitu resursseja niin tämä on viimeinen mahdollisuus vapauttaa ne.
	\param gViewHandler osoitin näkymän käsittelijään. Jokainen kosketus poikii kutsun sekä osuman saaneen widgetin käsittelijään että tähän. Widgetit hoidetaan ensin, lopuksi näkymä.
	Mikäli joitakin linkatuista proseduureista ei tarvita, on vastaavan argumentin arvon oltava NULL jolloin se jätetään käyttämättä.
*/
View::View(uint8_t elems, gTextParamStruct elemparams[], gPrepare preinit, gPrepare postinit, gPrepare preshow, gPrepare final, gViewHandler vh) {
	preInit = preinit;
	postInit = postinit;
	preShow = preshow;
	finalize = final;
	viewHandler = vh;
	viewBgColor = ILI9341_GRAY;
	if ( preInit ) {
		preInit( this );
	}
	for ( uint8_t cnt = 0; cnt < elems; cnt++ ) {
		switch ( elemparams[cnt].etype ) {
			case e_PGMTextArea: {
				add( new PGM_TextArea(elemparams[cnt].x1, elemparams[cnt].y1, elemparams[cnt].x2, elemparams[cnt].y2, elemparams[cnt].color_bg, elemparams[cnt].color_fg, (PGM_P *)elemparams[cnt].txt, elemparams[cnt].hnd ));
				break;
			}
			case e_TextArea: {
				add ( new TextArea(elemparams[cnt].x1, elemparams[cnt].y1, elemparams[cnt].x2, elemparams[cnt].y2, elemparams[cnt].color_bg, elemparams[cnt].color_fg, (char **)elemparams[cnt].txt, elemparams[cnt].hnd ));
				break;
			}
			case e_Caption: {
				add ( new Caption(elemparams[cnt].x1, elemparams[cnt].y1, elemparams[cnt].x2, elemparams[cnt].y2, elemparams[cnt].color_bg, elemparams[cnt].color_fg, elemparams[cnt].txt, elemparams[cnt].hnd ));
				break;
			}
			case e_Button: {
				add ( new Button(elemparams[cnt].x1, elemparams[cnt].y1, elemparams[cnt].x2, elemparams[cnt].y2, elemparams[cnt].color_bg, elemparams[cnt].color_fg, elemparams[cnt].txt, elemparams[cnt].hnd ));
				break;
			}
			case e_cartesian: {
				break;
			}
		}
	}
	if ( postInit ) {
		postInit( this );
	}
}

/*! \brief View-luokan destruktori

	Juuri ennen luokan tuhoamista kutsutaan finalize() -lopetuskäsittelijää jos sellainen on määritelty.
	Sen jälkeen kaikki näkymään kuuluvat widgetit tuhotaan ja merkataan näyttö likaiseksi s.o. että se pitää päivittää.
	Näkymän tuhoamisen jälkeisen päivityksen hoitaa se näkymä josta tähän tultiin, eli sen käsitelijä tsekkaa muuttujan screenIsDirty ja toimii vastaavasti.
	Juurinäkymää ei siis tietenkään passaa tuhota koska silloin ei ole enää ketään joka hoitaa hommat...
*/
View::~View() {
	if ( finalize ) finalize( this );
	elementList.deleteAll();
	screenIsDirty = true;
}

/*! \brief Uuden widgetin lisääminen näkymään listan viimeiseksi

	\param *element osoitin lisättävään widgettiin. Käyttäjän vastuulla on lisätä vain aitoja widgettejä!
*/
void View::add(void *element) {
	elementList.insertLast( element );
}

/*! \brief Näkymän päivitys

	Näkymä piirretään alusta alkaen uudelleen ja käsitellään mahdolliset eventit pois
*/
void View::show() {
	render();
	handleView();
}

/*! \brief Widgetin listaindeksin nouto osoittimen perusteella

	Metodi palauttaa widgetin indeksin näkymän widgetlistalla.
	Jollei osoitettu widget ole listalla, metodi palauttaa -1.
	\param *item osoitin widgettiin jonka indeksi halutaan tietää
*/
int8_t View::getItemIndex( void *item) {
gText *elem;
int8_t cnt;

	cnt = 0;
	elem = (gText *)elementList.getFirst();
	while ( elem ) {
		if ( elem == item ) {
			return cnt;
		}
		cnt++;
		elem = (gText *)elementList.getNext();
	}
	return -1;	// ei löytynyt
}

/*! \brief Widgetin osoittimen nouto listaindeksin perusteella

	Metodi palauttaa osoittimen widgetiin näkymän widgetlistan indeksin perusteella.
	Jollei listalta löydy annettua indeksi, metodi palauttaa NULL pointerin.
	Huom: listan ensimmäinen indeksi on 0.
	\param index halutun widgetin järjestysnumero listalla 
*/
void *View::getItem(uint8_t index) {
void *elem;
int8_t cnt;

	cnt = 0;
	elem = (gText *)elementList.getFirst();
	while ( elem ) {
		if ( index == cnt ) return elem;
		else {
			elem = (gText *)elementList.getNext();
			cnt++;
		}
	}
	return NULL;
}

/*! \brief Kolme nopeaa piippausta (näppäilyvirheet yms)
*/
void View::keyErrorBeep() {
	for ( uint8_t i = 0; i < 3; i++ ) {
		vTaskDelay(50);
		digitalWrite(BEEPER, HIGH);
		vTaskDelay(50);
		digitalWrite(BEEPER, LOW);
	}
}

/*! \brief Näkymän piirto näytölle

	Metodi valmistelee näytön piirron kutsumalla proseduuria preShow mikäli se oli konstruktorissa annettu.
	Sen jälkeen piirtoala siivotaan taustavärillä täyttäen ja näytetään widget-lista alusta loppuun.
	Lopuksi merkataan näyttö puhtaaksi eli ajantasaiseksi.
*/
void View::render() {
	gText *elem;
	if ( preShow ) preShow( this );
	else ILI9341_due_gText::_ili->fillScreen(viewBgColor);
	elem = (gText *)elementList.getFirst();
	while ( elem ) {
		elem->show();
		elem = (gText *)elementList.getNext();
	}
	screenIsDirty = false;
}

// kosketuksen tunnistus
uint8_t touching() {
	if (digitalRead( YM ) == LOW) return 1;
	else return 0;
}

//yksinkertainen järjestetty lista
static void insert_sort(uint16_t array[], uint8_t size) {
	uint16_t j;
	uint16_t save;
	
	for (uint16_t i = 1; i < size; i++) {
		save = array[i];
		for (j = i; j >= 1 && save < array[j - 1]; j--)
		array[j] = array[j - 1];
		array[j] = save;
	}
}

#define NUMSAMPLES 5

uint16_t x, y, z;

// kosketuskalvon inputtien viritys kosketuksen tunnistusta varten
void resetTouchPins() {
	pinMode( XP, OUTPUT );
	digitalWrite( XP, LOW );
	
	pinMode( XM, INPUT );
	digitalWrite( XM, LOW );
	
	pinMode( YP, INPUT );
	digitalWrite( YM, LOW );

	pinMode( YM, INPUT_PULLUP );
	digitalWrite( YM, HIGH );
}

// kosketuskalvon inputtien viritys X-akselin position tunnistusta varten
void setTouchPinsForX() {
	pinMode(YP, INPUT);
	pinMode(YM, INPUT);
	digitalWrite(YP, LOW);
	digitalWrite(YM, LOW);
	
	pinMode(XP, OUTPUT);
	pinMode(XM, OUTPUT);
	digitalWrite(XP, HIGH);
	digitalWrite(XM, LOW);
}

// kosketuskalvon inputtien viritys Y-akselin position tunnistusta varten
void setTouchPinsForY() {
	pinMode(XP, INPUT);
	pinMode(XM, INPUT);
	digitalWrite(XP, LOW);
	digitalWrite(XM, LOW);
	
	pinMode(YP, OUTPUT);
	pinMode(YM, OUTPUT);
	digitalWrite(YP, HIGH);
	digitalWrite(YM, LOW);
}

// kosketuskoordinaatin mittaus
void getPoint(uint16_t *x, uint16_t *y) {
	uint16_t samples[NUMSAMPLES];
	uint8_t i;
	uint16_t _x, _y;

	setTouchPinsForX();
	for (i=0; i<NUMSAMPLES; i++) samples[i] = analogRead(YP);
	#if NUMSAMPLES > 2
	insert_sort(samples, NUMSAMPLES);
	#endif
	#if NUMSAMPLES == 2
	if (samples[0] != samples[1]) { valid = 0; }
	#endif
	_x = (samples[NUMSAMPLES/2]);

	setTouchPinsForY();
	for (i=0; i<NUMSAMPLES; i++) samples[i] = analogRead(XM);
	#if NUMSAMPLES > 2
	insert_sort(samples, NUMSAMPLES);
	#endif
	#if NUMSAMPLES == 2
	if (samples[0] != samples[1]) { valid = 0; }
	#endif
	_y = (samples[NUMSAMPLES/2]);

	resetTouchPins();
	*x = map(_x,MIN_X,MAX_X, 0, DISP_W);
	*y = map(_y,MIN_Y,MAX_Y, 0, DISP_H);
}
//-----------------

extern boolean backLight;

/*! \brief Näkymän tapahtumankäsittelijä

	Tapahtumankäsittelijä havainnoi kosketuksia ja sellaisen tapahtuessa tekee seuraavaa:
	1.	tuorestetaan näytön taustavalo mikäli se olisi sattunut sammumaan timeouttiin.
	2.	Jos taustavalo oli päätää (eli näyttö oli "aktiivinen") niin
		-	annetaan kosketuksen merkkiääni,
		-	mitataan kosketuksen koordinaatit
		-	käydään läpi näkymän widget-lista lopusta alkuun (päällimmäisestä widgetistä pohjimmaiseen) ja tsekataan osuuko kosketus widgettiin
		-	kutsutaan osuman saaneen widgetin käsittelijää
		-	kutsutaan näkymän käsittelijää jos määritelty
		-	tarvittaessa tuorestetaan näyttö jos joku käsittelijöiden käynnistämä popup sotki sen
		-	odotellaan että kosketus päättyy jottei toisteta samaa kosketusta holtittomasti.
	Huom: Widgetin tai näkymän tapahtumankäsittelijä voi vapaasti luoda uuden View-luokan instanssin näyttääkseen jonkin popupin tai muun näkymän.
	Tällöin näkymät pinoutuvat rekursiivisesti ja käsittelijästä tullaan ulos vasta kun alemman tason näyttö on käsitelty loppuun asti.
	Tämän takia jokaisen handlerin jälkeen on tsekattava vieläkö näyttö on siinä asussa kuin kuvitellaan vai sotkiko joku alemman tason näyttö sen
	jolloin tarvitaan uudelleen renderöinti.
*/
void View::handleView() {
TickType_t xStartDelayTime;
const TickType_t xTouchBeepTime = BEEPERONTIME;
const TickType_t xBackLightOnTime = BACKLIGHTONTIME;
uint16_t x, y;
event_t event;
gText *elem;

	exitView = false;
	resetTouchPins();
	for ( ;; ) {
		if ( touching() ) {											// odotellaan kosketusta
			xTimerReset( backLightTimer, xBackLightOnTime );		// näytön taustavalolle lisää aikaa
			if ( backLight ) {										// jos taustavalo on päällä (eli näyttö on aktiivinen)
				xStartDelayTime = xTaskGetTickCount();				// otetaan aikamerkki piippausajastinta varten
				digitalWrite(BEEPER, HIGH);							// käynnistetään piippaus
				getPoint(&x, &y);									// mitataan kosketuksen koordinaatit
				event.eventID = eventTouch;							// rakennetaan eventti
				event.event_data.pos.x = x;
				event.event_data.pos.y = y;
				vTaskDelayUntil(&xStartDelayTime, xTouchBeepTime);	// ajastetaan piippaus loppuun alkumerkin mukaan (50 ms)
				digitalWrite(BEEPER, LOW);							// ja mykistetään piippari
				elem = (gText *)elementList.getLast();				// käydään läpi kaikki näytöllä näkyvät elementit aloittaen päällimmäisestä
				while ( elem ) {
					if ( elem->isInside( x, y ) ) {
						elem->handleEvent( this, event );			// ...ja jos kosketus osuu niin käsitellään
						break;
					}
					elem = (gText *)elementList.getPrev();
				}
				if ( viewHandler ) viewHandler( this, event );		// lopuksi yleiskäsittely jos on määritelty
				if ( !exitView && screenIsDirty ) render();			// jos handleri näytti popup-ikkunaa niin joudutaan ehkä regeneroimaan näyttö
			}
			else {
				digitalWrite( BACKLIGHT, HIGH );					// jos taustavalo oli pimeänä, se sytytetään kosketuksesta
				backLight = true;									// mutta ei tehdä muuta
			}
			while ( touching() ) {									// odotellaan että kosketus päättyy
				taskYIELD();
			}
			vTaskDelay(100);											// ja vielä 100 ms ettei tule bounceja
			if ( exitView ) {
				exitView = false;
				return;									// jos joku laittoi lopetusbitin pystyyn niin häivytään ( ja toivotaan että takana on yhä edellinen ikkuna :) )
			}
		}
		else taskYIELD();											// jos ei kosketusta niin annetaan muille peliaikaa
	}
}
